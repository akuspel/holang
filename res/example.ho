
/* --- HoLang Example ---
 * an example of valid HoLang code
 * 
 *	  --- NOTE ---
 * the code currently passes*
 * the	Parsing step up 'till
 * // <--- Works Until
 * !!! unless marked with !!!
 * // <--- Doesn't work
 * 
 * (* this doesn't mean it does anything,
 *	only that the Parser recognises the
 *	syntax )
 */

// --- Types ---
#type u8 = unique byte; // Unique Reference to byte, needs a cast to assign <--->
#type char = byte;

var my_u8 : u8 = 123;
var cast_test : byte = char(1.0) + 5 - byte(my_u8);

#type Vec2 = [2]float;
#type Vec3 = [3]float;
#type Vec4 = [4]float;

#type Color = Vec4; // Non-unique reference, no casting needed!
#type Color255 = [4]u8;

// Colors
var COLOR_RED : immutable int = 10 + 1;

#const STRING_BUF_SIZE = 1024;
#type StringBuf = [STRING_BUF_SIZE + 1]byte;
#type cstring = ^byte; // Null terminated string

#const MAX_ACTORS = 100;
#type ActorID = struct {
	idx : int,
	gen : int,
};
#type Actor = struct {
	// Nested Structs
	// NOTE: the struct type
	//	   must be defined
	//	   separately
	id : ActorID,
	
	// Other stuff
	name : cstring,
	health : uint,
	
	// Data
	flags : u8,
	_ : u8, // Unnamed members, for alignment purposes
	pos : Vec2,
	col : Color,
	
	// Horrible idea: Methods!
	// fn damage <self> (val : uint) {
	// 	self.health -= val;
	
};

// Other method declaration
// fn set_name <self : Actor> (name : cstring) {
// 	self.name = name;
// }

// --- Variables ---
#type ActorArray = [MAX_ACTORS]Actor;
var actors : ActorArray;
var string_data : StringBuf;

var num_actors : uint;
#const skibidiasa = -3 + 5;
var skibidi_b : int =  0 - 1 + 3;
var skibidi_a : int = -1 + 3;


#const AAA = -(1 + 3);
#type Zing = int;

// Entry statement
entry {
	
	// These variables are local to our entry scope
	// And can't be called from functions
	var x : int;
	var y : immutable Zing = int(12 - 3 + uint(x));
	
	x = (y + 1);
	y = x; // Throws an error
	
	actors[10 + AAA].id = {
		idx = 10 + (actors[12 - AAA].id.idx * 3),
		gen = 3 * y,
	};
	
	var my_vec : Vec4 = Vec4 {
		1, 2, 3 * (5.1 + float(x)), 4
	};
	
	my_vec = { 0, 0, 0, 1 };
	var my_other_vec : Vec4 = actors[x + y].col;
	
	x += y*5;
	
	// Conditionals
	// if (a == 1) {
		
	// 	var z : int;
	// 	var h : float = 12.3 * 3.2 + 1.0;
	// } else {
		
	// 	if (b == 2) x = 2;
	// }
	
}


// --- Functions ---

/*
// <--- Works Until
fn new_actor(name : cstring, pos : Vector2, col : Color255) -> Actor {
	if (name == 0) return; // C-like single command execution
	if (num_actors >= MAX_ACTORS) return Actor {}
	
	// Constant expression conditional
	// No runtime calculation cost (to be or not to be)
	when (MAX_ACTORS < 100) {
		
		print("This is a thing!"); // Hopefully I do figure out strings...
	}
	
	// There are NO runtime constants
	// ( #const is limited to file space )
	// But you can define immutable variables
	var test : immutable int = 0b0100;
	
	actor.name = name;
	actor.pos  = pos;
	actor.col = Color {
		float(col.r) / 256,
		float(col.g) / 256,
		float(col.b) / 256,
		float(col.a) / 256,
	}; // Array literal
	
	// THOUGHT:
	// Array (and struct) literals
	// Must have typename included
	// So the parser can parse the
	// Literal based on that, and
	// After parsing typecheck if
	// Literal and variable type match!
	// (happy cat noises)
	
	id = ActorID {
		int(num_actors),
		0,
	};
	
	return // Automatically return named returns
}

// Automatically get types from function
var actor, id = new_actor("Homeshift Boy", Vec2 {2, 3.4}, Color255 {10, 200, 30, 255});
var second_id = new_actor("Other boy", Vec2 {10, 11}, Color255 {1, 2, 3, 4}).id; // Return selection
print(actor.name);

// Nice example, say I so myself!
