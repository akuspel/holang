
#const MY_STRING_LIT = "This
is a string literal!


\n also: \" haha quotes \"";
/* --- HoLang Example ---
 * an example of valid HoLang code
 * 
 *	  --- NOTE ---
 * the code currently passes*
 * the	Parsing step up 'till
 * // <--- Works Until
 * !!! unless marked with !!!
 * // <--- Doesn't work
 * 
 * (* this doesn't mean it does anything,
 *	only that the Parser recognises the
 *	syntax )
 */

// --- Types ---
#type u8 = unique byte; // Unique Reference to byte, needs a cast to assign <--->
#type char = byte;

var my_u8 : u8 = 123;
var cast_test : byte = char(int, 1.0) + 5 - byte(u8, my_u8);

#type Vec2 = [2]float;
#type Vec3 = [3]float;
#type Vec4 = [4]float;

#type Color = Vec4; // Non-unique reference, no casting needed!
#type Color255 = [4]u8;

// IDEA: enums, which act like
//		 constants, but cool
// #enum MyEnum(int) = {
// 	ZERO = 0,
// 	BALLIN = 1,
// 	MOVING = 2,
// 	FLIPPN = 3,
// };

// Colors
var COLOR_RED : immutable int = 10 + 1;

#const STRING_BUF_SIZE = 1024;
#type StringBuf = [STRING_BUF_SIZE + 1]byte;
#type cstring = ^byte; // Null terminated string

#const MAX_ACTORS = 100;
#type ActorID = struct {
	idx : int,
	gen : int,
};
#type Actor = struct {
	// Nested Structs
	// NOTE: the struct type
	//	   must be defined
	//	   separately
	id : ActorID,
	
	// Other stuff
	name : cstring,
	health : uint,
	
	// Data
	flags : u8,
	_ : u8, // Unnamed members, for alignment purposes
	pos : Vec2,
	col : Color,
	
	// Horrible idea: Methods!
	// fn damage <self> (val : uint) {
	// 	self.health -= val;
	
};

// Other method declaration
// fn set_name <self : Actor> (name : cstring) {
// 	self.name = name;
// }

// --- Variables ---
#type ActorArray = [MAX_ACTORS]Actor;
var actors : ActorArray;
var string_data : StringBuf;

var num_actors : uint;
#const skibidiasa = -3 + 5;
var skibidi_b : int =  0 - 1 + 3;
var skibidi_a : int = -1 + 3;


#const AAA = -(1 + 3);
#type Zing = int;

#type int_ptr = ^int;

// Entry statement
entry {
	
	// These variables are local to our entry scope
	// And can't be called from functions
	var x : int;
	var y : immutable Zing = int(uint, 12 - 3 + uint(int, x));
	
	x = (y + 1);
	y = x; // Throws an error
	
	actors[10 + AAA].id = ActorID {
		idx = 10 + (actors[12 - AAA].id.idx * 3),
		gen = 3 * y,
	};
	
	var my_vec : Vec4 = Vec4 {
		1, 2, 3 * (5.1 + float(int, x)), 4
	};
	
	my_vec = { 0, 0, 0, 1 };
	var my_other_vec : Vec4 = actors[x + y].col;
	
	x += y*5;
	
	var mog : immutable int = 100;
	var dog : int_ptr = as_ptr(int_ptr, mog);
	
	// Conditionals
	// if (a == 1) {
		
	// 	var z : int;
	// 	var h : float = 12.3 * 3.2 + 1.0;
	// } else {
		
	// 	if (b == 2) x = 2;
	// }
	
	var fax_bro : bool;
	fax_bro = bool(int, x == y);
	fax_bro = true && fax_bro;
	
	var my_str : string;
	var h : cstring;
	var b : byte = 10;
	{
		raw; // Current scope is raw from here on
		my_str._data = 10;
		my_str = {
			_data = 0,
			_size = 0,
		};
		
		h = cstring(byte_ptr, my_str._data) + as_ptr(cstring, b);
		b = deref(cstring, h) + 100;
	}
	
	raw;
	deref(cstring, h) = 100;
}


// --- Functions ---
// fn str_cmp(a : &string, b : &string) -> bool {
// 	raw; // Allows transparent access
	
// 	if (a._size != b._size) return false;
	
// 	for (var i : byte_ptr; i < a._size; i += 1) {
// 		var char_a : byte = deref(byte_ptr, a._data + i);
// 		var char_b : byte = deref(byte_ptr, b._data + i);
// 		if (char_a != char_b) return false;
// 	}
//	for (var i : int; i < 10; i += 1) { ... } // normal for loop
//	for (var i in my_array)  { ... } // for each
//	for (a._size != b._size) { ... } // for true
// 	return true;
// }

// fn str_len(s : &string) -> int {
// 	raw; return s._size;
// }

/*
// <--- Works Until
fn new_actor(name : cstring, pos : Vector2, col : Color255) -> Actor {
	if (name == 0) return; // C-like single command execution
	if (num_actors >= MAX_ACTORS) return Actor {}
	
	// Constant expression conditional
	// No runtime calculation cost (to be or not to be)
	when (MAX_ACTORS < 100) {
		
		print("This is a thing!"); // Hopefully I do figure out strings...
	}
	
	// There are NO runtime constants
	// ( #const is limited to file space )
	// But you can define immutable variables
	var test : immutable int = 0b0100;
	
	actor.name = name;
	actor.pos  = pos;
	actor.col = Color {
		float(col.r) / 256,
		float(col.g) / 256,
		float(col.b) / 256,
		float(col.a) / 256,
	}; // Array literal
	
	// THOUGHT:
	// Array (and struct) literals
	// Must have typename included
	// So the parser can parse the
	// Literal based on that, and
	// After parsing typecheck if
	// Literal and variable type match!
	// (happy cat noises)
	
	id = ActorID {
		int(num_actors),
		0,
	};
	
	return // Automatically return named returns
}

// Automatically get types from function
var actor, id = new_actor("Homeshift Boy", Vec2 {2, 3.4}, Color255 {10, 200, 30, 255});
var second_id = new_actor("Other boy", Vec2 {10, 11}, Color255 {1, 2, 3, 4}).id; // Return selection
print(actor.name);

// Nice example, say I so myself!
