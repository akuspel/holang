/* --- HoLang Example ---
 * an example of valid HoLang code
 * 
 *	  --- NOTE ---
 * the code currently passes*
 * the	Parsing step up 'till
 * // <-- Works Until
 * !!! unless marked with !!!
 * // <-- Doesn't work
 * 
 * (* this doesn't mean it does anything,
 *	only that the Parser recognises the
 *	syntax )
 */

// --- Types ---
#type u8 = unique byte; // Unique Reference to byte, needs a cast to assign <--->

#type Vec2 = [2]float;
#type Vec3 = [3]float;
#type Vec4 = [4]float;

#type Color = Vec4; // Non-unique reference, no casting needed!
#type Color255 = [4]u8;

#const STRING_BUF_SIZE = 1024;
#type StringBuf = opaque [STRING_BUF_SIZE + 1]byte; // Extra for null character
#type cstring = ^byte; // Null terminated string

// --- Struct Stuff ---
#type Vertex = struct {
	pos : Vec3,
	col : Color,
};

#type Triangle = [3]Vertex;
#const MAX_TRIANGLES = 2048;
#type TriangleBuff = [MAX_TRIANGLES]Triangle;

// Opaque types (array, struct) members
// Can only be accessed in raw scopes
#type Mesh = opaque struct {
	col : Color,
	
	n_tris : int,
	tris : TriangleBuff,
};

// --- Global Variables ---
var my_global : int; // Defaults to zero
var MY_FAKE_CONSTANT : immutable uint = 75;

// Constant expressions are evaluated
// During the parsing step
var _a : float = 10.0 - 12 / (MAX_TRIANGLES - 512); // Evaluated during parsing
var _b : float = (_a + float(uint, MY_FAKE_CONSTANT)) * 2; // Evaluated at runtime

// --- Functions ---
fn clamp(v : int, min : int, max : int) -> int {
	if (bool(int, v < min)) return min;
	if (bool(int, v > max)) return max;
	return v;
}

fn max(a : int, b : int) -> (c : int) {
	c = a;
	if (bool(int, b > a)) c = b;
	return; // Auto return named returns
}

fn new_mesh(tris : int, col : Color255) -> Mesh {
	
	var mesh : Mesh;
	
	raw { // Mark scope as raw to edit mesh data
		mesh.col = {
			float(u8, col[0]) / 256,
			float(u8, col[1]) / 256,
			float(u8, col[2]) / 256,
			float(u8, col[3]) / 256,
		};
		
		mesh.n_tris = clamp(tris, 0, MAX_TRIANGLES);
	}
	
	return mesh;
}

fn mesh_add_tri(mesh : &Mesh, tri : Triangle) {
	raw {
		if (bool(int, mesh.n_tris >= MAX_TRIANGLES)) return;
		
		// References can be mutated
		mesh.tris[mesh.n_tris] = tri;
		mesh.n_tris += 1;
	}
	
	// You may be asking:
	//   " if you have references, (safe btw)
	//     the hell you need pointers for? "
	//
	// And the answer is...
	// Well, cause I want them!
	// Also cause we can do beloved
	// C-style strings with ease (IO)
}

// Would be called like:
//     var MY_COLOR : immutable Color255 =
//         {0, 255, 100, 255};
//
//     my_mesh.set_color(MY_COLOR);
//
// Semantically identical to:
//     fn set_color(mesh : &Mesh, col : Color255) { ... }
//     set_color(my_mesh, MY_COLOR);
//
// So, this probably never gets implemented!
// NOTE: immutable variables can't be passed as references!

// --- Entry Point ---
// Execution begins from an entry block, where
// Defined variables are local to that block,
// And can't be accessed globally
entry {
	var x : int = 1;
	var y : int = 2;
	var z : int =
		-(x + y) * 13 + x * 2 + y;

	// <-- Works until
	// You can write logic in an entry frame
	while (bool(int, z < x + y)) {
		z += 1 + max(x, y);
		if (bool(int, (z / 2) == 0)) {
			y -= 1;
		}
	}
	
	clamp(z, y, x);
	
	// <--- Works until
	// If we only want en entry function, we can call
	// One in an entry block, E.G. entry { main() }
	var my_mesh : Mesh = new_mesh(100, { 255, 100, 53, 200 });
	mesh_add_tri(my_mesh, {});
	// The parser checks that ref members
	// Are a valid variable of given type
}