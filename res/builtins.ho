
/* --- HoLang Builtins ---
 * documentation for builtin
 * types and functions in HoLang
 */

// --- Types ---
// --  Base Types  --
// Base types are the core of the language
// And are defined as such:
//
// byte:
//     unsigned 8-bit integer
// int:
//     signed 64-bit integer
// uint:
//     unsigned 64-bit integer
// float:
//     64-bit floating point
// bool:
//     64-bit boolean

// --  Support Types  --
// These types are builtins that rely
// On the core types of HoLang

#type byte_ptr = ^byte;
// The byte pointer is the A and O
// Of low level data management
// E.G. the base pointer for C-style strings

#type string = opaque struct {
	_data : byte_ptr,
	_size : int,
};
// The builtin string type is made
// For handling strings in a nicer
// And safer way than C-style ptrs

#type vec2 = [2]float;
#type vec3 = [3]float;
#type vec4 = [4]float;
// The builtin vector array types
// Make game programming a breeze

#type mat3x3 = [3]vec3;
#type mat4x4 = [4]vec4;
// In addition basic square matrices
// Are provided out of the box

// --- Functions ---
// --  Raw Builtins  --
// Raw builtins are not really functions,
// But keywords with special handling in
// The parser.  In code, they are called
// In a function-like style, but special
// Rules are applied,  E.G. must provide
// Constant parameters

// Casting:
// to_type(from_type, expression)
// E.G. int(bool, a && b)
// Written in generic form:
fn [$T : type] T($F : type, expr : F) -> T
// Note: such syntax isn't supported by
// 		 the language itself,   this is
//		 merely a visualisation

// Pointers:
fn deref($F : ^$T, expr : F) -> T
// Dereferences a pointer of given type
// Can be used in expressions, or assigned
// To in raw scopes

fn as_ptr($T : type, $V : var_signature(T^)) -> T
// Gets the pointer of a variable / variable member
// Can only be used in raw scopes

fn alloc($T : type, $I : int) -> ^T
// Allocates  to the heap at compile time
// No runtime allocations happen from its
// Use.   Must be assigned directly to an
// Immutable variable

// --  Strings  --
// Several helper functions
// For working with strings

// Whole function is marked as raw and
// Can't be used outside of raw scopes
fn raw _strlen(_data : byte_ptr) -> int {
	if (bool(byte_ptr, _data == 0)) return 0;
	if (bool(byte, deref(byte_ptr, _data) == 0))
		return 0;
	
	for (var i : int; true; i += 1) {
		if (bool(byte, deref(byte_ptr, _data + byte_ptr(int, i)) == 0))
			return i;
	}
	
	return 0;
}
// The _strlen function is used to calculate
// Lengths for C-style strings. Not intended
// For use in casual settings, hence the raw
// And _ prefix

fn to_string(_data : byte_ptr) -> string {
	var new_string : string;
	raw {
		new_string = {
			_data = _data,
			_size = _strlen(_data),
		};
	}
	
	return new_string;
}
// The to_string fn converts a byte pointer into
// An opaque string, which is a little less scary

fn string_len(str : &string) -> (len : int) {
	raw { len = str._size; }
	return;
}
// Gets the length of a string, must be
// Passed a valid string variable as ref

fn substring(str : &string, start : int, end : int) -> string {
	var sub  : string;
	var size : int;
	
	raw { size = max(0, str._size); }
		
	var from : int = min(start,   size);
	var to   : int = max(min(end, size), from);
	
	raw {
		sub._data = str._data + byte_ptr(int, from);
		sub._size = to - from;
	}
	
	return sub;
}
// Creates a substring from a given string
// While making sure both have a valid length
//
// Does not take into account the validity of
// UTF8 characters

